package com.ustglobal.rapido.mapping.domain.model.businessentity.datasource.xsd;

import com.ustglobal.rapido.mapping.domain.shared.DomainErrorCode;
import com.ustglobal.rapido.mapping.domain.shared.DomainValidator;
import com.ustglobal.rapido.mapping.domain.shared.FilePersistenceException;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.kohsuke.args4j.CmdLineException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.xml.sax.SAXException;

import com.sun.tools.xjc.BadCommandLineException;
import com.ustglobal.rapido.mapping.domain.model.businessentity.datasource.*;
import com.ustglobal.rapido.mapping.domain.model.businessentity.datasource.parserequest.ParseFromFileRequest;
import com.ustglobal.rapido.mapping.domain.model.businessentity.datasource.parserequest.ParseRequest;

import com.ustglobal.rapido.parser.JsonixWrapper;

import jdk.nashorn.api.scripting.ScriptObjectMirror;

/**
 * Parses DataSourceDefinition from an XSD file
 */
@SuppressWarnings("restriction")
@Service
public class XSDFileDataSourceDefinitionParser implements DataSourceDefinitionParser {

	private static final Logger LOGGER = LoggerFactory.getLogger(XSDFileDataSourceDefinitionParser.class);

	@Autowired
	private DataSourceFactoryProvider dataSourceFactoryProvider;

	@Value("${rapido.file.save.dir}")
	private String fileSaveDir;

	@Override
	public DataSourceDefinition parse(ParseRequest request) {
		DomainValidator.isInstanceOf(ParseFromFileRequest.class, request, DomainErrorCode.DATASOURCE_IMPORT_ERROR);

		ParseFromFileRequest fromFileRequest = (ParseFromFileRequest) request;
		String masterFilePath = fromFileRequest.getMasterFilePath();
		DataSourceDefinition xsdDataSourceDefinition;
		try {
			createOutputDirectoryIfNotExist();
			new JsonixWrapper().parseXSD(fileSaveDir, FilenameUtils.getBaseName(masterFilePath), masterFilePath);

			xsdDataSourceDefinition = createNewDataSourceDefinition(request);

			parseFileGeneratedByRapidoXSDParser(xsdDataSourceDefinition, request);

		} catch (CmdLineException | BadCommandLineException | NoSuchMethodException | ScriptException
				| ParserConfigurationException | SAXException | IOException e) {
			throw new XSDParseException("Exception Occured while parsing xsd datasource definition", e);
		}finally {
			try {
				FileUtils.forceDelete(new File(fileSaveDir));
			} catch (IOException e) {
				throw new XSDParseException("Exception Occured while deleting the directory", e);
			}
		}

		return xsdDataSourceDefinition;
	}

	/**
	 * This method build the DataSourceDefinition based on the JS file generated by
	 * the rapidoxsdparser
	 * 
	 * @param parsedJSFileFunctionName
	 *            - Function name which need to be processed inside javascript file.
	 * @param definitionFilePath
	 *            - Path of xsd file which need to be processed.
	 * @param dataSourceDefinition
	 * @param dataSourceFactory
	 * @return
	 * @throws ScriptException
	 * @throws NoSuchMethodException
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * @throws IOException
	 */
	@SuppressWarnings({ "unchecked" })
	private DataSourceDefinition parseFileGeneratedByRapidoXSDParser(DataSourceDefinition dataSourceDefinition,
			ParseRequest request)
			throws ScriptException, NoSuchMethodException, ParserConfigurationException, SAXException, IOException {

		String definitionFilePath = ((ParseFromFileRequest) request).getMasterFilePath();

		Object jsFunctionResult = invokeJSFunction(definitionFilePath, getAbsolutePathOfJSFile(definitionFilePath));

		if (jsFunctionResult instanceof ScriptObjectMirror) {
			Map<String, Object> parsedResultMap = (Map<String, Object>) XSDParserUtil
					.getScriptObjectMirrorValue((ScriptObjectMirror) jsFunctionResult);

			String rootElementName = XSDParserUtil.getRootElementName(definitionFilePath);

			new XSDParserUtil().addFieldDefinitionsToDataSourceFromParsedJSFile(
					(List<Object>) parsedResultMap.get("elementInfos"), (List<Object>) parsedResultMap.get("typeInfos"),
					rootElementName, null, "", dataSourceDefinition,
					dataSourceFactoryProvider.getDataSourceFactory(DataSourceDefinitionType.XSD));
		} else {
			LOGGER.info("The object returned is not a valid ScriptObjectMirror");
		}
		return dataSourceDefinition;

	}

	/**
	 * Invoke the JS function inside the parsed file.
	 * 
	 * @param definitionFilePath
	 * @param parsedFileAbsolutePath
	 * @return
	 * @throws ScriptException
	 * @throws FileNotFoundException
	 * @throws NoSuchMethodException
	 */
	private Object invokeJSFunction(String definitionFilePath, String parsedFileAbsolutePath)
			throws ScriptException, FileNotFoundException, NoSuchMethodException {
		ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName("nashorn");
		scriptEngine.eval(new FileReader(parsedFileAbsolutePath));
		Invocable invocable = (Invocable) scriptEngine;
		ScriptObjectMirror jsFunctionResult = (ScriptObjectMirror) invocable
				.invokeFunction(FilenameUtils.getBaseName(definitionFilePath) + "_Module_Factory");

		return jsFunctionResult.get(FilenameUtils.getBaseName(parsedFileAbsolutePath));
	}

	/**
	 * This method is used to generate the absolute path for saving the parsed JS
	 * file generated by rapidoxsdparser
	 * 
	 * @param definitionFilePath
	 * @return
	 */
	private String getAbsolutePathOfJSFile(String definitionFilePath) {
		Path filePath = Paths
				.get(String.join(File.separator, fileSaveDir, FilenameUtils.getBaseName(definitionFilePath) + ".js"));
		DomainValidator.notNull(filePath, DomainErrorCode.DATASOURCE_IMPORT_ERROR);
		return filePath.toAbsolutePath().toString();
	}

	private void createOutputDirectoryIfNotExist() {
		File destination = new File(fileSaveDir);
		if (!destination.exists()) {
			if (!destination.mkdir()) {
				throw new FilePersistenceException("Output directory cannot be created.");
			}
		}
	}

	private DataSourceDefinition createNewDataSourceDefinition(ParseRequest request) {
		return dataSourceFactoryProvider.getDataSourceFactory(DataSourceDefinitionType.XSD).createDataSourceDefinition(
				new CreateDataSourceDefinitionRequest(UUID.randomUUID().toString(), request.getDataSourceName()));
	}

}
